# 流水线自动发布微服务项目
### 将微服务项目自动化部署到 kubernetes 需要考虑的需求
- 尽量完全自动化部署，无需过多人工干预
- 可以选择升级某个、某些微服务
- 在部署、升级微服务时，可对微服务某些特性做配置，例如命名空间、副本数量
### Pipeline 编写思路
- 在微服务架构中，会涉及几个、几十个微服务，如果每个服务都创建一个 item ，势必给运维维护成本增加很大，因此需要编写一个通用 Pipeline 脚本，将这些微服务部署差异化部分使用 Jenkins 参数化，人工交互确认发布的微服务、环境配置等。
- 但这只是解决用户交互层面，在 kubernetes 实际部署项目用 YAML 创建对应资源，现在问题是如何接收用户交互参数，自动化生成 YAML 文件，这就会用到 Helm 完成 YAML 文件高效复用和微服务部署。
### 编写 Pipeline 流水线脚本
1. 将 harbor 认证和 gitlab 认证保存到 Jenkins 凭据
    - 管理 Jenkins > 安全 > 管理凭据 > Jnekins > 添加凭据 > Username with password
    - 分别添加连接 gitlab 和 harbor 的用户名到 Jenkins 凭据，然后获取该凭据 ID 替换到脚本中 docker_registry_auth 和 git_auth 变量的值。
2. 将 kubeconfig 存储在 Jenkins ，用于 slave 镜像里 kubectl 连接 kubernetes 集群
    - 管理 Jenkins > Managed files > Add a new Config > Custom file -> Content （字段内容是 kubeconfig ）
    - 将 kubectl 、 helm 工具封装到 Slave 镜像中，并通过 Config File Provider 插件存储连接 kubernetes 集群的 kubeconfig 认证文件，然后挂载到 Slave 容器中，这样就能用 `kubectl apply deploy.yaml --kubeconfig=config` 管理 kubernetes 应用了，为提高安全性， kubeconfig 文件可分配权限。
- 
    ```jenkinspipeline
    #!/usr/bin/env groovy
    // 所需插件: Git Parameter/Git/Pipeline/Config File Provider/kubernetes/Extended Choice Parameter
    // 公共
    def registry = "192.168.1.222"
    // 项目
    def project = "microservice"
    def git_url = "http://192.168.1.222:88/root/microservice.git"
    def gateway_domain_name = "gateway.ctnrs.com"
    def portal_domain_name = "portal.ctnrs.com"
    // 认证
    def image_pull_secret = "registry-pull-secret"
    def harbor_auth = "e18afb8f-72bd-4962-999d-a5709570ed37"
    def git_auth = "f521cfb4-071c-4c19-8550-32c0a5cf175e"
    // ConfigFileProvider ID
    def k8s_auth = "fa18b4bc-8e67-4732-8f0f-09fd7bee3a3c"

    pipeline {
    agent {
        kubernetes {
            label "jenkins-slave"
            yaml """
    apiVersion: v1
    kind: Pod
    metadata:
    name: jenkins-slave
    spec:
    containers:
    - name: jnlp
        image: "${registry}/library/jenkins-slave-jdk:1.8"
        imagePullPolicy: Always
        volumeMounts:
        - name: docker-cmd
            mountPath: /usr/bin/docker
        - name: docker-sock
            mountPath: /var/run/docker.sock
        - name: maven-cache
            mountPath: /root/.m2
    volumes:
        - name: docker-cmd
        hostPath:
            path: /usr/bin/docker
        - name: docker-sock
        hostPath:
            path: /var/run/docker.sock
        - name: maven-cache
        hostPath:
            path: /tmp/m2
    """
            }
        
        }
        parameters {
            gitParameter branch: '', branchFilter: '.*', defaultValue: 'origin/master', description: '选择发布的分支', name: 'Branch', quickFilterEnabled: false, selectedValue: 'NONE', sortMode: 'NONE', tagFilter: '*', type: 'PT_BRANCH'        
            extendedChoice defaultValue: 'none', description: '选择发布的微服务', \
            multiSelectDelimiter: ',', name: 'Service', type: 'PT_CHECKBOX', \
            value: 'gateway-service:9999,portal-service:8080,product-service:8010,order-service:8020,stock-service:8030'
            choice (choices: ['ms', 'demo'], description: '部署模板', name: 'Template')
            choice (choices: ['1', '3', '5', '7'], description: '副本数', name: 'ReplicaCount')
            choice (choices: ['ms'], description: '命名空间', name: 'Namespace')
        }
        stages {
            stage('拉取代码'){
                steps {
                    checkout([$class: 'GitSCM', 
                    branches: [[name: "${params.Branch}"]], 
                    doGenerateSubmoduleConfigurations: false, 
                    extensions: [], submoduleCfg: [], 
                    userRemoteConfigs: [[credentialsId: "${git_auth}", url: "${git_url}"]]
                    ])
                }
            }
            stage('代码编译') {
                // 编译指定服务
                steps {
                    sh """
                    mvn clean package -Dmaven.test.skip=true
                    """
                }
            }
            stage('构建镜像') {
            steps {
                withCredentials([usernamePassword(credentialsId: "${harbor_auth}", passwordVariable: 'password', usernameVariable: 'username')]) {
                    sh """
                    docker login -u ${username} -p '${password}' ${registry}
                    for service in \$(echo ${Service} |sed 's/,/ /g'); do
                        service_name=\${service%:*}
                        image_name=${registry}/${project}/\${service_name}:${BUILD_NUMBER}
                        cd \${service_name}
                        if ls |grep biz &>/dev/null; then
                            cd \${service_name}-biz
                        fi
                        docker build -t \${image_name} .
                        docker push \${image_name}
                        cd ${WORKSPACE}
                    done
                    """
                    configFileProvider([configFile(fileId: "${k8s_auth}", targetLocation: "admin.kubeconfig")]){
                        sh """
                        # 添加镜像拉取认证
                        kubectl create secret docker-registry ${image_pull_secret} --docker-username=${username} --docker-password=${password} --docker-server=${registry} -n ${Namespace} --kubeconfig admin.kubeconfig |true
                        # 添加私有chart仓库
                        helm repo add  --username ${username} --password ${password} myrepo http://${registry}/chartrepo/${project}
                        """
                    }
                }
            }
            }
            stage('Helm部署到K8S') {
            steps {
                sh """
                common_args="-n ${Namespace} --kubeconfig admin.kubeconfig" # helm公共参数
                
                for service in  \$(echo ${Service} |sed 's/,/ /g'); do
                    service_name=\${service%:*}
                    service_port=\${service#*:}
                    image=${registry}/${project}/\${service_name}
                    tag=${BUILD_NUMBER}  # 镜像标签是构建编号
                    # helm与用户交互的参数：服务名、镜像地址、镜像标签、副本数量、镜像端口、镜像仓库认证secret
                    helm_args="\${service_name} --set image.repository=\${image} --set image.tag=\${tag} --set replicaCount=${replicaCount} --set imagePullSecrets[0].name=${image_pull_secret} --set service.targetPort=\${service_port} myrepo/${Template}"

                    # 判断是否为新部署
                    if helm history \${service_name} \${common_args} &>/dev/null;then
                    action=upgrade
                    else
                    action=install
                    fi

                    # 针对服务启用ingress
                    if [ \${service_name} == "gateway-service" ]; then
                    helm \${action} \${helm_args} \
                    --set ingress.enabled=true \
                    --set ingress.host=${gateway_domain_name} \
                    \${common_args}
                    elif [ \${service_name} == "portal-service" ]; then
                    helm \${action} \${helm_args} \
                    --set ingress.enabled=true \
                    --set ingress.host=${portal_domain_name} \
                    \${common_args}
                    else
                    helm \${action} \${helm_args} \${common_args}
                    fi
                done
                # 查看Pod状态
                sleep 10
                kubectl get pods \${common_args}
                """
            }
            }
        }
    }
    ```
### 流水线脚本与源代码一起版本管理
- Jenkinsfile 文件建议与源代码一起版本管理，实现流水线即代码（ Pipeline as Code ）， Jenkins 从 Git 仓库中读取 Jenkinsfile
    - 自动为所有分支创建流水线脚本
    - 方便流水线代码复查、追踪、迭代
    - 可被项目成员查看和编辑