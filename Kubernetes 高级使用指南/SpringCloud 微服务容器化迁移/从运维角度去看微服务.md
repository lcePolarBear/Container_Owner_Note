# 从运维角度去看微服务
### 横向比较单体应用模式和微服务模式
- 早期的项目或初始项目基本都是单体应用，易于部署和测试，但是随着时间的推移，不可避免地变更导致了代码膨胀到难以维护，维护和部署的难度越来越大，并且导致代码性能收到既有约束，难以扩展。
- 而微服务将功能模块拆分开放置在多个运行环境，通过注册中心和 api 网关向访问者提供请求。那么组件的开发和部署就可以独立，拓展性大大增加，并使得每个独立组件都能有独立的数据存储。当然，微服务带来的运维成本、内部架构复杂性、服务治理等要求也更高了。
### Java 推动了微服务框架的发展
- Spring Boot：快速开发微服务的框架，目标是微服务组建的单体构建
- Spring Cloud：基于 SpringBoot 实现的一个完整的微服务解决方案
- Dubbo：阿里巴巴开源的微服务治理框架
### 常见微服务架构
前端请求（公网地址） - 负载均衡 - api 网关（基于 url 做转发，并暴露给 LB） - 注册中心（注册中心发现并注册微服务动态地址，用于微服务与网关、微服务之间的通讯） - 微服务组件（通过负载均衡组成实例，地址并不写死，所以通过注册中心注册动态地址） - 访问数据库、存储服务（I/O 数据） - 配置中心（实现微服务配置的集中管理，动态生效）
### 思考微服务项目架构
1. 微服务间如何通信？   REST API,RPC,MQ
2. 微服务之间如何发现彼此？ 通过控制中心
3. 组件之间的调用关系是怎样的？根据业务逻辑调用
4. 哪个服务作为网站的统一入口？负载均衡
5. 哪些服务需要提供对外访问？网关（内网），负载均衡和前端（外网）
6. 微服务的部署、更新、扩容方式？
7. 有状态和无状态的区分？存储、网络身份、启动顺序。微服务本身就是无状态的
### 注册中心的作用
- 微服务太多会面临的问题
    1. 一个微服务重启或漂移后 ip 地址会修改，怎么记录？
    2. 一个微服务创建多个副本，负载均衡怎么实现？
    3. 一个微服务的某个副本不可用了，怎么判断？
- 通过注册中心记录微服务的信息，用于解决这些问题，注册中心会定期向微服务的副本发送心跳信息用于探测存活，
### 网关的作用
1. 基于 url 转发到不同的微服务
2. 智能路由（每个微服务会有多个实例）
3. 访问控制（限流、权限）
### 在 kubernetes 部署项目的流程
1. 使用 dockerfile 制作镜像
2. 使用 deployment/statefulset/deamonset 控制器部署镜像
3. 使用 service/ingress 对外暴露应用
4. 使用 prometheus+grafana 进行监控，使用 ELK 收集日志
5. 日常运维